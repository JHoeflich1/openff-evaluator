"""
A collection of classes for loading and manipulating statistics data files.
"""
import copy
from enum import Enum
from io import StringIO

import numpy as np
import pandas as pd
from simtk import unit


class ObservableType(Enum):
    """The supported statistics which may be extracted / stored
    in statistics data files.
    """

    PotentialEnergy = 'PotentialEnergy'
    KineticEnergy = 'KineticEnergy'
    TotalEnergy = 'TotalEnergy'
    Temperature = 'Temperature'
    Volume = 'Volume'
    Density = 'Density'
    Enthalpy = 'Enthalpy'


class StatisticsArray:
    """
    A data object for storing and retrieving statistics generated by an OpenMM simulation.
    """

    @property
    def number_of_items(self):
        """int: The number of data items in the array."""
        return len(self._internal_data[ObservableType.PotentialEnergy])

    def __init__(self, potential_energies, kinetic_energies, total_energies,
                 temperatures, volumes, densities, enthalpies):
        """Constructs a new StatisticsArray object.

        Parameters
        ----------
        """

        self._internal_data = {
            ObservableType.PotentialEnergy: potential_energies,
            ObservableType.KineticEnergy: kinetic_energies,
            ObservableType.TotalEnergy: total_energies,
            ObservableType.Temperature: temperatures,
            ObservableType.Volume: volumes,
            ObservableType.Density: densities,
            ObservableType.Enthalpy: enthalpies,
        }

    def get_observable(self, observable_type):
        """Return the data for a given observable.

        Parameters
        ----------
        observable_type: ObservableType
            The type of observable to retrieve.

        Returns
        -------
        Quantity[List]
            The data.
        """

        if not self.has_observable(observable_type):
            return None

        return self._internal_data[observable_type]

    def has_observable(self, observable_type):
        """Return the data for a given statistic.

        Parameters
        ----------
        observable_type: ObservableType
            The type of observable to retrieve.

        Returns
        -------
        bool
            True if data for the `observable_type` is available.
        """
        return observable_type in self._internal_data

    def save_as_pandas_csv(self, file_path):

        data = np.array([
            self._internal_data[ObservableType.PotentialEnergy] / unit.kilojoule_per_mole,
            self._internal_data[ObservableType.KineticEnergy] / unit.kilojoule_per_mole,
            self._internal_data[ObservableType.TotalEnergy] / unit.kilojoule_per_mole,
            self._internal_data[ObservableType.Temperature] / unit.kelvin,
            self._internal_data[ObservableType.Volume] / unit.nanometer**3,
            self._internal_data[ObservableType.Density] / unit.gram * unit.milliliter,
            self._internal_data[ObservableType.Enthalpy] / unit.kilojoule_per_mole])

        data = data.transpose()

        columns = [
            "Potential Energy (kJ/mole)",
            "Kinetic Energy (kJ/mole)",
            "Total Energy (kJ/mole)",
            "Temperature (K)",
            "Box Volume (nm^3)",
            "Density (g/mL)",
            "Enthalpy (kJ/mole)"
        ]

        data_frame = pd.DataFrame(data=data, columns=columns)
        data_frame.to_csv(file_path)

    @classmethod
    def from_openmm_csv(cls, file_path, pressure=None):

        file_contents = None

        with open(file_path, 'r') as file:

            file_contents = file.read()

            if len(file_contents) < 1:
                raise ValueError('The statistics file is empty.')

            file_contents = file_contents[1:]

        string_object = StringIO(file_contents)
        data = pd.read_csv(string_object)

        if 'Potential Energy (kJ/mole)' not in data:
            raise ValueError('The statistics file does not contain a Potential Energy column.')

        potential_energies = list(data['Potential Energy (kJ/mole)']) * unit.kilojoule / unit.mole

        if 'Kinetic Energy (kJ/mole)' not in data:
            raise ValueError('The statistics file does not contain a Kinetic Energy column.')

        kinetic_energies = list(data['Kinetic Energy (kJ/mole)']) * unit.kilojoule / unit.mole

        if 'Total Energy (kJ/mole)' not in data:
            raise ValueError('The statistics file does not contain a Total Energy column.')

        total_energies = list(data['Total Energy (kJ/mole)']) * unit.kilojoule / unit.mole

        if 'Temperature (K)' not in data:
            raise ValueError('The statistics file does not contain a Temperature column.')

        temperatures = list(data['Temperature (K)']) * unit.kelvin

        if 'Box Volume (nm^3)' not in data:
            raise ValueError('The statistics file does not contain a Box Volume column.')

        volumes = list(data['Box Volume (nm^3)']) * unit.nanometer * unit.nanometer * unit.nanometer

        if 'Density (g/mL)' not in data:
            raise ValueError('The statistics file does not contain a Density column.')

        densities = list(data['Density (g/mL)']) * unit.gram / unit.milliliter

        enthalpies = None

        if pressure is not None:

            enthalpies = []

            for total_energy, volume in zip(total_energies, volumes):

                enthalpies.append((total_energy + volume * pressure *
                                   unit.AVOGADRO_CONSTANT_NA) / unit.kilojoule_per_mole)

            enthalpies *= unit.kilojoule_per_mole

        return cls(potential_energies, kinetic_energies, total_energies,
                   temperatures, volumes, densities, enthalpies)

    @classmethod
    def from_pandas_csv(cls, file_path):

        file_contents = None

        with open(file_path, 'r') as file:

            file_contents = file.read()

            if len(file_contents) < 1:
                raise ValueError('The statistics file is empty.')

        string_object = StringIO(file_contents)
        data = pd.read_csv(string_object)

        if 'Potential Energy (kJ/mole)' not in data:
            raise ValueError('The statistics file does not contain a Potential Energy column.')

        potential_energies = list(data['Potential Energy (kJ/mole)']) * unit.kilojoule / unit.mole

        if 'Kinetic Energy (kJ/mole)' not in data:
            raise ValueError('The statistics file does not contain a Kinetic Energy column.')

        kinetic_energies = list(data['Kinetic Energy (kJ/mole)']) * unit.kilojoule / unit.mole

        if 'Total Energy (kJ/mole)' not in data:
            raise ValueError('The statistics file does not contain a Total Energy column.')

        total_energies = list(data['Total Energy (kJ/mole)']) * unit.kilojoule / unit.mole

        if 'Temperature (K)' not in data:
            raise ValueError('The statistics file does not contain a Temperature column.')

        temperatures = list(data['Temperature (K)']) * unit.kelvin

        if 'Box Volume (nm^3)' not in data:
            raise ValueError('The statistics file does not contain a Box Volume column.')

        volumes = list(data['Box Volume (nm^3)']) * unit.nanometer * unit.nanometer * unit.nanometer

        if 'Density (g/mL)' not in data:
            raise ValueError('The statistics file does not contain a Density column.')

        densities = list(data['Density (g/mL)']) * unit.gram / unit.milliliter

        enthalpies = None

        if 'Enthalpy (kJ/mole)' in data:
            enthalpies = list(data['Enthalpy (kJ/mole)']) * unit.kilojoule_per_mole

        return cls(potential_energies, kinetic_energies, total_energies,
                   temperatures, volumes, densities, enthalpies)

    @classmethod
    def from_existing(cls, existing_instance, data_indices=None):
        """Creates a new StatisticsArray from an existing array. If
        a set of data indices are provided, only a subset of data will
        be copied across from the existing instance.

        Parameters
        ----------
        existing_instance: StatisticsArray
            The existing StatisticsArray to clone
        data_indices: list of int, optional
            A set of indices, which indicate which data points to copy
            from the original objext. If None, all data points will be
            copied.

        Returns
        -------
        StatisticsArray
            The created StatisticsArray object.
        """

        potential_energies = copy.deepcopy(existing_instance.get_observable(ObservableType.PotentialEnergy))
        kinetic_energies = copy.deepcopy(existing_instance.get_observable(ObservableType.KineticEnergy))
        total_energies = copy.deepcopy(existing_instance.get_observable(ObservableType.TotalEnergy))
        temperatures = copy.deepcopy(existing_instance.get_observable(ObservableType.Temperature))
        volumes = copy.deepcopy(existing_instance.get_observable(ObservableType.Volume))
        densities = copy.deepcopy(existing_instance.get_observable(ObservableType.Density))
        enthalpies = copy.deepcopy(existing_instance.get_observable(ObservableType.Enthalpy))

        potential_energies /= unit.kilojoule_per_mole
        kinetic_energies /= unit.kilojoule_per_mole
        total_energies /= unit.kilojoule_per_mole
        temperatures /= unit.kilojoule_per_mole
        volumes /= unit.kilojoule_per_mole
        densities /= unit.kilojoule_per_mole
        enthalpies /= unit.kilojoule_per_mole

        return_object = StatisticsArray(list(np.array(potential_energies)[data_indices]) * unit.kilojoule_per_mole,
                                        list(np.array(kinetic_energies)[data_indices]) * unit.kilojoule_per_mole,
                                        list(np.array(total_energies)[data_indices]) * unit.kilojoule_per_mole,
                                        list(np.array(temperatures)[data_indices]) * unit.kilojoule_per_mole,
                                        list(np.array(volumes)[data_indices]) * unit.kilojoule_per_mole,
                                        list(np.array(densities)[data_indices]) * unit.kilojoule_per_mole,
                                        list(np.array(enthalpies)[data_indices]) * unit.kilojoule_per_mole)

        return return_object
